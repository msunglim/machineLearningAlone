# -*- coding: utf-8 -*-
"""MarketAndMachineLearning3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XZU4bsSiSyOfN6Maz5NJSNMjCmagb5wq
"""



import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier
import numpy as np
from sklearn.model_selection import train_test_split

# domi
bream_length = [25.4,26.3,26.5,29.0,29.0,29.7,29.7,30.0,30.7,30.9,31.0,31.0,31.5,32.0,32.0,33.0,33.5,33.5,34.0,34.0]
bream_weight= [430.3,450.0,460.0,490.0,450.0,500.0,475.0,500.0,500.0,540.0,600.0,600.0,610.0,615.0,610.0,650.0,675.0,685.0,620.0,680.0]
# print(len(bream_length))= 20

# binga
smelt_length =[9.8,10.5,10.6,11.0,11.2,11.3,11.5,11.8,11.9,12.0,12.2,12.4,13.0,15.0]
smelt_weight=[6.7,7.5,7.0,9.7,9.8,8.7,10.0,9.9,9.8,12.2,13.4,12.2,19.7,19.9]
# print(len(smelt_length)) = 14

# --------------------
length = bream_length + smelt_length
weight = bream_weight+ smelt_weight
fish_data = np.column_stack((length, weight))

# fish_target is like an answer sheet
# fish_target = [1]*len(bream_length) + [0]*len(smelt_length)
fish_target = np.concatenate((np.ones(len(bream_length)), np.zeros(len(smelt_length))))

# input_arr = np.array(fish_data)
# target_arr = np.array(fish_target)

# index = np.arange(len(bream_length)+len(smelt_length))
# np.random.shuffle(index)

# train_input = input_arr[index[:len(bream_length)]]
# train_target = target_arr[index[:len(bream_length)]]

# test_input = input_arr[index[len(bream_length):]]
# test_target= target_arr[index[len(bream_length):]]

train_input, test_input, train_target, test_target = train_test_split(
    fish_data, fish_target, stratify= fish_target, random_state=len(fish_data))

# well mixed dataset

kn = KNeighborsClassifier()
kn = kn.fit(train_input, train_target)

kn.score(test_input, test_target)
#this test returns array[0] which means it is smelt.
print(kn.predict([[25,150]]))

#returns distance from point to its neighbors and indexes of neighbors based on Kn_neighbors
distances, indexes = kn.kneighbors([[25,150]])
# print(distances) index is generated based on the graph.
# print(indexes)

plt.scatter(train_input[:,0], train_input[:, 1])
# mark triangle on input point
plt.scatter(25,150, marker= '^')

# mark diamond on points close to input point
plt.scatter(train_input[indexes,0], train_input[indexes,1], marker='D')

# plt.xlim(0,700)
plt.xlabel('length')
plt.ylabel('weight')
plt.show()

#-------------------------------------
#Main Idea
#scaled graph

mean = np.mean(train_input, axis=0)
std = np.std(train_input, axis=0)

train_scaled = (train_input - mean)/std

kn = kn.fit(train_scaled, train_target)

test_scaled = (test_input - mean)/std
kn.score(test_scaled, test_target)

new = ([25,150]- mean)/std
distances, indexes = kn.kneighbors([new])

plt.scatter(train_scaled[:,0], train_scaled[:, 1])
# mark triangle on input point
plt.scatter(new[0], new[1], marker = '^')
# mark diamond on points close to input point
plt.scatter(train_scaled[indexes,0], train_scaled[indexes,1], marker='D')

plt.xlabel('length')
plt.ylabel('weight')
plt.show()
