# -*- coding: utf-8 -*-
"""MarketAndMachineLearning5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gkYnxET9d-s27Lm9oGP6BSw5pMNAaYLh
"""

import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error

# # nong o , overfitting
# perch_length = [25.4,26.3,26.5,29.0,29.0,29.7,29.7,30.0,30.7,30.9,31.0,31.0,31.5,32.0,32.0,33.0,33.5,33.5,34.0,34.0]
# perch_weight= [430.3,450.0,460.0,490.0,450.0,500.0,475.0,500.0,500.0,540.0,600.0,600.0,610.0,615.0,610.0,650.0,675.0,685.0,620.0,680.0]

# underfitting
perch_length = [25.4,26.3,26.5,29.0,29.0,29.7,29.7,30.0,30.7,30.9,31.0,31.0,31.5,32.0,32.0,33.0,33.5,33.5,34.0,34.0]
perch_weight= [430.3,450.0,460.0,490.0,490.0,495.0,500.0,501.0,502.0,540.0,600.0,600.0,610.0,615.0,610.0,650.0,675.0,675.5,680.0,680.0]
# print(len(perch_length))= 20

#we don't need stratify for regression.
#train, test input = perch_length, and train,test target = perch_weight
train_input, test_input, train_target, test_target = train_test_split(
    perch_length, perch_weight, random_state= len(perch_length)
)

#make the arrays look like [
#  [],
#  [], 
# ]
train_input = np.array(train_input).reshape(-1,1)
test_input = np.array(test_input).reshape(-1,1)
#do this, otherwise we have typeerror: only integer scalar arrays can be converted to a scalar index site:stackoverflow.com
train_target = np.array(train_target).reshape(-1,1) 
knr = KNeighborsRegressor()
knr.fit(train_input, train_target)


input_length = 37

knr_predicted_weight = knr.predict([[input_length]])
print("knr regression:", knr_predicted_weight)

distances, indexes = knr.kneighbors([[input_length]])

plt.scatter(train_input, train_target)

plt.scatter(train_input[indexes],train_target[indexes],marker ='D')

plt.scatter(input_length, knr_predicted_weight, marker='^')
plt.show();

from sklearn.linear_model import LinearRegression

lr = LinearRegression()

lr.fit(train_input, train_target)

coef = np.array(lr.coef_).reshape(-1,)
intercept = np.array(lr.intercept_).reshape(-1,)


predicted_weight = lr.predict([[input_length]])
print("linear regression:", predicted_weight)
print("y = ", coef,"x + ", intercept)
plt.scatter(train_input, train_target)
plt.scatter( input_length, predicted_weight, marker ='^')

ymin = 20*coef + intercept
ymax = 40*coef + intercept
print(ymin, ymax)
plt.plot([20, 40], [ymin, ymax])

plt.show()

# print(lr.score(train_input, train_target))
# print(lr.score(test_input, test_target))

train_poly = np.column_stack((train_input**2, train_input))
test_poly = np.column_stack((test_input**2, test_input))

lr = LinearRegression()
lr.fit(train_poly, train_target)

predicted_weight_poly = lr.predict([[input_length**2, input_length]])

coef_poly = np.array(lr.coef_).reshape(-1,)
intercept_poly = np.array(lr.intercept_).reshape(-1,)

plt.scatter(train_input, train_target)
plt.scatter(input_length, predicted_weight_poly, marker ='^')

print(coef_poly
      ,intercept_poly)
point = np.arange(20,40)
plt.plot(point, coef_poly[0]*point**2 +coef_poly[1]*point + intercept_poly)
plt.show()


print(lr.score(train_poly, train_target))
print(lr.score(test_poly, test_target))